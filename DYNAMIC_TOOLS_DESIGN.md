# Dynamic Tool Creation - Design Proposal

## Overview
Enable Ally to generate reusable Python/TypeScript tools that persist across conversations within profile contexts.

## Architecture

### 1. Tool Creation Flow

```
User Request → LLM Analysis → Tool Specification → Code Generation → Validation → Installation → Registration
```

### 2. Components

#### ToolCreatorAgent
**Location**: `src/agents/tool-creator.md`

Specialized agent with capabilities:
- Analyze user requirements and determine tool schema
- Generate JSON schemas from natural language descriptions
- Create Python/TypeScript implementations using templates
- Handle dependency management
- Validate generated code for common issues

**Visible Tools**:
- `Write` (for code generation)
- `Bash` (for validation, dependency checks)
- `Read` (for template loading)
- Internal tool: `install-dynamic-tool` (see below)

#### DynamicToolInstaller (New Tool)
**Location**: `src/tools/DynamicToolInstaller.ts`

```typescript
class DynamicToolInstaller extends BaseTool {
  name = 'install-dynamic-tool';
  description = 'Install a dynamically created tool into the current profile';
  internalTool = true; // Only visible to tool-creator agent

  async executeImpl(params: {
    toolName: string;
    description: string;
    schema: JSONSchema;
    code: string; // Python or TypeScript
    runtime: 'python3' | 'node';
    dependencies?: string[];
    requiresConfirmation?: boolean;
    usageGuidance?: string;
  }): Promise<ToolResponse> {
    // 1. Validate tool name (kebab-case, no conflicts)
    // 2. Create plugin directory structure
    // 3. Write plugin.json manifest
    // 4. Write implementation file
    // 5. Create requirements.txt or package.json
    // 6. Install dependencies in isolated environment
    // 7. Validate tool works (test execution)
    // 8. Register tool with ToolManager
    // 9. Persist to profile plugins

    return { success: true, toolName, pluginPath };
  }
}
```

#### Code Templates
**Location**: `src/templates/tool-templates/`

**Python Template** (`python-tool.template.py`):
```python
#!/usr/bin/env python3
"""
{{TOOL_DESCRIPTION}}

Auto-generated by Ally on {{GENERATION_DATE}}
"""
import json
import sys
from typing import Any, Dict

def execute(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Main execution function.

    Parameters:
    {{PARAM_DOCS}}

    Returns:
        Result dictionary with success status and data
    """
    # Validate parameters
    {{VALIDATION_CODE}}

    # Implementation
    {{IMPLEMENTATION_CODE}}

    return {
        "success": True,
        "result": result
    }

if __name__ == "__main__":
    try:
        # Read JSON input from stdin
        input_data = json.load(sys.stdin)

        # Execute tool logic
        result = execute(input_data)

        # Output JSON result
        json.dump(result, sys.stdout, indent=2)
        sys.exit(0)

    except Exception as e:
        error_result = {
            "success": False,
            "error": str(e),
            "error_type": type(e).__name__
        }
        json.dump(error_result, sys.stdout, indent=2)
        sys.exit(1)
```

**TypeScript Template** (`typescript-tool.template.ts`):
```typescript
/**
 * {{TOOL_DESCRIPTION}}
 *
 * Auto-generated by Ally on {{GENERATION_DATE}}
 */

interface ToolParams {
  {{PARAM_INTERFACES}}
}

interface ToolResult {
  success: boolean;
  result?: any;
  error?: string;
}

async function execute(params: ToolParams): Promise<ToolResult> {
  try {
    // Validation
    {{VALIDATION_CODE}}

    // Implementation
    {{IMPLEMENTATION_CODE}}

    return { success: true, result };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

// Main execution
(async () => {
  const input = await readStdin();
  const params = JSON.parse(input);
  const result = await execute(params);
  console.log(JSON.stringify(result, null, 2));
  process.exit(result.success ? 0 : 1);
})();

async function readStdin(): Promise<string> {
  return new Promise((resolve) => {
    let data = '';
    process.stdin.on('data', (chunk) => data += chunk);
    process.stdin.on('end', () => resolve(data));
  });
}
```

### 3. Storage Structure

```
~/.ally/profiles/{profile}/plugins/dynamic-{toolName}-{timestamp}/
├── plugin.json              # Manifest
├── tool.py or tool.ts       # Implementation
├── requirements.txt         # Python deps (if applicable)
├── package.json             # Node deps (if applicable)
├── .ally-metadata.json      # Creation metadata
└── tests/                   # Optional test cases
    └── test_tool.py
```

**Metadata Format** (`.ally-metadata.json`):
```json
{
  "createdAt": "2025-11-23T10:30:00Z",
  "createdBy": "tool-creator-agent",
  "conversationId": "conv-123",
  "userPrompt": "Create a tool that validates email addresses",
  "generationMethod": "template",
  "version": "1.0.0",
  "lastUsed": "2025-11-23T15:45:00Z",
  "usageCount": 42
}
```

### 4. Security & Validation

#### Pre-Installation Checks
1. **Static Analysis**
   - No dangerous imports (`os.system`, `eval`, `exec`, subprocess without validation)
   - No file system access outside allowed paths
   - No network access without explicit permission

2. **Schema Validation**
   - Valid JSON Schema
   - Required fields present
   - Type consistency

3. **Name Validation**
   - Kebab-case format
   - No conflicts with existing tools
   - No reserved names

4. **Sandbox Execution Test**
   - Test tool with sample inputs
   - Verify JSON I/O format
   - Check exit codes
   - Timeout protection (5s max for test)

#### Runtime Protection
- Execute in isolated virtual environments
- Resource limits (CPU, memory, execution time)
- No elevated privileges
- Network access only if explicitly enabled in manifest
- File system access restricted to workspace

### 5. User Experience

#### Creation Flow

**User**: "Create a tool that validates JSON against a schema"

**Ally** (using tool-creator agent):
1. Analyzes requirement
2. Generates JSON schema for tool parameters
3. Creates Python implementation
4. Shows preview to user
5. Asks for confirmation
6. Installs and registers tool
7. Confirms: "Created tool `validate-json-schema`. You can now use it in this profile."

#### Management Commands

**Slash Commands** (optional):
- `/tools list-dynamic` - List all dynamically created tools
- `/tools inspect {tool-name}` - Show tool details and code
- `/tools remove {tool-name}` - Remove a dynamic tool
- `/tools edit {tool-name}` - Modify an existing dynamic tool
- `/tools export {tool-name}` - Export tool for sharing

#### Tool Discovery
Tools automatically appear in agent contexts where `visible_to` matches.

### 6. Template Categories

#### Built-in Template Types
1. **Data Processing**
   - CSV/JSON transformations
   - Data validation
   - Format conversions

2. **API Interactions**
   - HTTP requests with authentication
   - Webhook handlers
   - REST client wrappers

3. **File Operations**
   - Custom parsers
   - File converters
   - Batch processors

4. **Calculations**
   - Domain-specific computations
   - Statistical analysis
   - Data aggregation

### 7. Advanced Features

#### Tool Chaining
Generated tools can call other tools via ToolManager:
```python
# In generated tool code
from ally_sdk import call_tool

result = call_tool('other-tool', {'param': value})
```

#### Incremental Improvement
- Track tool usage and errors
- Agent can suggest improvements
- Versioning support (tool-v1, tool-v2)

#### Sharing
- Export tool as standalone plugin
- Import tools from other profiles
- Community tool repository (future)

## Implementation Phases

### Phase 1: Core Infrastructure (Week 1)
- [ ] Create DynamicToolInstaller tool
- [ ] Build Python and TypeScript templates
- [ ] Implement validation layer
- [ ] Add profile plugin integration

### Phase 2: Agent Integration (Week 2)
- [ ] Create tool-creator agent
- [ ] Implement schema generation from NL
- [ ] Add code generation logic
- [ ] Build testing framework

### Phase 3: UX & Management (Week 3)
- [ ] Add slash commands for tool management
- [ ] Implement tool inspection/editing
- [ ] Create usage analytics
- [ ] Add export/import functionality

### Phase 4: Advanced Features (Week 4)
- [ ] Tool chaining support
- [ ] Incremental improvement system
- [ ] Template library expansion
- [ ] Community sharing (optional)

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Generated code quality | High | Use proven templates, validation, test execution |
| Security vulnerabilities | Critical | Static analysis, sandboxing, explicit permissions |
| Dependency conflicts | Medium | Isolated environments per tool |
| Poor tool descriptions | Medium | Interactive refinement, usage tracking |
| Tool name collisions | Low | Validation, namespacing with timestamps |

## Success Metrics

- Time from request to working tool < 30 seconds
- 90%+ of generated tools work on first try
- Zero security incidents from generated tools
- Tools reused across 3+ conversations
- User satisfaction with tool quality

## Open Questions

1. Should tools be mutable after creation? (Versioning vs in-place updates)
2. How to handle tools that need system dependencies? (apt, brew, etc.)
3. Should there be a community tool repository?
4. How to handle tool deprecation/cleanup?
5. Should tools be exportable to standalone plugins for sharing?
